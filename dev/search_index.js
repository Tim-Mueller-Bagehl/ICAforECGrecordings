var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started-Guide","page":"Getting Started","title":"Getting Started Guide","text":"","category":"section"},{"location":"getting_started/#1.-Read-the-data","page":"Getting Started","title":"1. Read the data","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"data = read_dataset_from_dat(\"./data/foetal_ecg.dat\")","category":"page"},{"location":"getting_started/#2.-Call-select-the-Seperator-and-call-solve()","page":"Getting Started","title":"2. Call select the Seperator and call solve()","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"shibbs_signals = solve(ShibbsSeperator(), data)\njade_signals = solve(JadeSeperator(), data)","category":"page"},{"location":"getting_started/#3.-Plot","page":"Getting Started","title":"3. Plot","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"plot_dataset(shibbs_signals)\nplot_dataset(jade_signals)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/#Full-Example","page":"Getting Started","title":"Full Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.activate(temp=true)\nPkg.add(url=\"https://github.com/Tim-Mueller-Bagehl/ICAforECGrecordings\")\nPkg.resolve()\nPkg.instantiate()\nPkg.add(\"Plots\")\nimport ICAforECGrecordings\nusing ICAforECGrecordings: whiten, plot_dataset, read_dataset_from_dat, solve, JadeSeperator, ShibbsSeperator\nusing Plots: savefig\n\n\n# load data\ndata = read_dataset_from_dat(\"./data/foetal_ecg.dat\")\nprintln(\"Data loaded successfully.\")\n\n# create plots dir\ntry \n    mkdir(\"plots\")\ncatch e\n    println(e)\nend\n\n\n# save plots \nsavefig(plot_dataset(solve(ShibbsSeperator(), data)), \"plots/shibbs.png\")\nsavefig(plot_dataset(solve(JadeSeperator(), data)), \"plots/jade.png\")\nsavefig(plot_dataset(solve(PicardoSeperator(), data)), \"plots/picardo.png\")","category":"page"},{"location":"#ICAforECGrecordings","page":"Home","title":"ICAforECGrecordings","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ICAforECGrecordings.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ICAforECGrecordings.cumulant_matrices-Tuple{AbstractMatrix, Number}","page":"Home","title":"ICAforECGrecordings.cumulant_matrices","text":"cumulant_matrices(X::AbstractMatrix, m::Number)\n\nBlind separation of real signals with SHIBBS.\n\nArguments\n\nX::AbstractMatrix: Matrix that contains the signals that have to be unmixed. \nm::Number: The number of signals that should be extracted from X.\n\nReturns  CM=cumulant_matrices(X, m) a NxN*nbcm cumulant matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.extract_sources-Tuple{AbstractMatrix, AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.extract_sources","text":"extract_sources(V::AbstractMatrix, W::AbstractMatrix) -> B::Matrix{Float64}\n\nCompute a scaled and permuted separation matrix B given a demixing matrix V and a mixing matrix W, ordering output components by estimated energy and ensuring a consistent sign convention.\n\nArguments\n\nV::AbstractMatrix{<:Real}   Demixing (unmixing) matrix of size mxm (e.g., returned by a joint diagonalizer).\nW::AbstractMatrix{<:Real}   Mixing matrix of size mxm (inverse of the true source mixing).\n\nReturns\n\nB::Matrix{Float64}   Separation matrix of size mxm such that B * X yields estimated source signals. Rows of B are ordered by descending source energy and each row is scaled to have a positive first coefficient (up to a small offset).\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.fourth_order_cumulant_matrices-Tuple{AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.fourth_order_cumulant_matrices","text":"fourth_order_cumulant_matrices(X::AbstractMatrix) -> Matrix{E}\n\nCompute the set of fourth-order cumulant matrices for the signals stored as rows of X.\n\nArguments\n\nX::AbstractMatrix{<:Number}   An nxT data matrix, where each of the n rows is a sequence of T observations.\n\nReturns\n\nCM::Matrix{E} where E = eltype(X)   An nx(nnbcm) matrix formed by horizontally concatenating `nbcm = n(n+1)÷2` individual nxn cumulant blocks.   Each block corresponds to the fourth-order cumulant of the i-th and j-th signals (with i ≥ j).\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.gradient-Tuple{AbstractMatrix, AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.gradient","text":"gradient(Y :: AbstractMatrix,psiY :: AbstractMatrix)\n\nCompute the gradient of the current signals\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.jade-Tuple{AbstractMatrix, AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.jade","text":"jade(data::AbstractMatrix{<:Real}) -> Matrix{Float64}\n\nPerform Blind Source Separation on multichannel time-series data using the JADE (Joint Approximate Diagonalization of Eigen-matrices) algorithm.\n\nArguments\n\ndata_w::AbstractMatrix{<:Real}   A matrix of size (n_samples, n_signals + 1) where the first column is time in seconds and the remaining columns are the observed signals.\nW_white::AbstractMatrix{<:Real} The whitening matrix of size (n_signals, n_signals) used to preprocess the data.\n\nReturns\n\nA matrix of size (n_samples, n_signals + 1) where the first column is time and the remaining columns are the estimated source signals after applying JADE.\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.joint_diagonalization-Tuple{AbstractMatrix, Real, Number}","page":"Home","title":"ICAforECGrecordings.joint_diagonalization","text":"joint_diagonalization(CM::AbstractMatrix, threshhold::Real, m::Number)\n\nBlind separation of real signals with SHIBBS.\n\nArguments\n\nCM::AbstractMatrix: Matrix that contains the signals that have to be unmixed. \n\n-threshhold::Real: A threshhold for the for the rotation\n\nm::Number: The number of signals that should be extracted from CM. \n\nReturns  V = joint_diagonalization(CM, threshhold, m) a NxN diagonalized matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.joint_diagonalization_new","page":"Home","title":"ICAforECGrecordings.joint_diagonalization_new","text":"joint_diagonalization_new(CM_in::AbstractMatrix, T::Int; max_sweeps::Int=10)\n\nCompute an approximate joint diagonalization of a set of K symmetric mxm matrices that are concatenated horizontally in CM_in, using a Jacobi-style algorithm.\n\nArguments\n\nCM_in::AbstractMatrix{<:Real}   Input matrix of size m x (m*K).  Each contiguous block of m columns   corresponds to one symmetric matrix to be jointly diagonalized.\nT::Int   A scaling parameter (often the number of samples) used to set the rotation threshold.\nmax_sweeps::Int=10   Maximum number of full sweeps over all index pairs before terminating.\n\nReturns\n\nV::Matrix{Float64}   An mxm orthogonal matrix whose columns jointly diagonalize the blocks.\nCM::Matrix{Float64}   The transformed version of CM_in, such that each mxm block is as close to   diagonal as possible under the rotation V.\n\n\n\n\n\n","category":"function"},{"location":"#ICAforECGrecordings.line_search-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, Number, Int64, Bool, String}","page":"Home","title":"ICAforECGrecordings.line_search","text":"line_search(Y :: AbstractMatrix,W :: AbstractMatrix,direction :: AbstractMatrix,current_loss :: Number,ls_tries :: Int,verbose :: Bool,distribution :: String)\n\nPerforms a backtracking line search, starting from Y and W, in the direction direction\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.line_search-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, T, Int64}} where T<:Real","page":"Home","title":"ICAforECGrecordings.line_search","text":"line_search(Y :: AbstractMatrix,signs :: AbstractMatrix,direction :: AbstractMatrix,current_loss :: T,ls_tries :: Int) where {T<:Real}\n\nPerforms a backtracking line search, starting from Y and W, in the direction direction\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.load_example_data-Tuple{}","page":"Home","title":"ICAforECGrecordings.load_example_data","text":"load_example_data()\n\nLoad example data from a .dat file for testing purposes. Returns a matrix containing the data.\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.loss-Tuple{AbstractMatrix, AbstractMatrix, String}","page":"Home","title":"ICAforECGrecordings.loss","text":"loss(Y::AbstractMatrix,W::AbstractMatrix,distribution::String)\n\ncompute the loss function for Y and W\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.loss-Tuple{AbstractMatrix, AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.loss","text":"loss(Y :: AbstractMatrix,signs :: AbstractMatrix)\n\nReturns the loss function, evaluated for the current signals\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.picard","page":"Home","title":"ICAforECGrecordings.picard","text":"function picard(X :: AbstractMatrix, params ::Dict)\n\nRuns the Picard algorithm for ICA #Arguments\n\nX::AbstractMatrix : Matrix that contains the signal that have to be unmixed\nparams::Dict : Dictionary of optional Parameters\n\n#Optional Arguments\n\nm::Int : Size for L-BFGS memory Typical values range between 3-15 default 7\nmaxiter::Int : Maximal number of iterations for the algorithm default 100\nmode::String : choose between orthogonal picard ->\"ortho\"(deafult) and standard picard -> \"standard\"\ntol::Float : choose tolerance for stopping criterion default 1e-8\nlambda_min::Float : Constant used to regularize the Hessian approximation default 1e-2\nls_tries::Int : Number of tries allowed for the backtracking line search default 10\nwhiten::Bool : If true, the signals are whitened befor running ICA default true\nverbose::Bool : If true, prints the information about the algorithm default false\nw_init::AbstractMatrix : Initial rotation matrix for the algorithm default empty\npython_defaults::Bool : If true uses Python-compatible defaults for the algorithm default false\ndistribution::String : Distribution used for the distribution-based ICA Possible values: \"logistic\"(default) or \"logcosh\"\nrenormalization::String : Renormalization method used for the distribution-based ICA Possible values: \"original\" (default) or \"pythonlike\"\n\n\n\n\n\n","category":"function"},{"location":"#ICAforECGrecordings.picard_standard-Union{Tuple{B}, Tuple{A}, Tuple{AbstractMatrix, Int64, Int64, Int64, A, B, Int64, Bool}, Tuple{AbstractMatrix, Int64, Int64, Int64, A, B, Int64, Bool, String}, Tuple{AbstractMatrix, Int64, Int64, Int64, A, B, Int64, Bool, String, String}} where {A, B<:Real}","page":"Home","title":"ICAforECGrecordings.picard_standard","text":"picard_standard(X :: AbstractMatrix, m :: Int, maxiter :: Int, precon, tol :: Float32, lambda_min :: Float32, ls_tries :: Int, verbose :: Bool)\n\nRuns the Picard algorithm detailed in: https://arxiv.org/abs/1706.08171\n\nArguments\n\nX::AbstractMatrix: Matrix that contains the signals that have to be unmixed. \nm::Int :  Size of L-BFGS's memory.\nmaxiter::Int : Maximal number of iterations for the algorithm\nprecon::Int : Choose wich Hessian approximation is Used. 1 -> H1 2->H2 H2 is more costly but can greatly accelerate convergence\ntol::Float32 : tolerance for the stopping criterion. Iterations stop when the norm of the projected gradient gets smaller than tol.\nlambda_min::Float32 : Constant used to regularize the Hessian approximation. The eigenvalues of the approximation that are below lambdamin are shifted to lambdamin.\nls_tries : Number of tries allowed for the backtracking line-search. When that number is exceeded, the direction is thrown away and the gradient is used instead\nverbose::Bool : If true, prints the informations about the algorithm.\ndistribution::String : logistic or logcosh. The distribution to use for the score function\nrenormalization::String : original or pythonlike. The method for Hessian renormalization\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.picardo-Union{Tuple{A}, Tuple{Z}, Tuple{AbstractMatrix, Int64, Int64, Z, A, Int64, Bool}} where {Z, A<:Real}","page":"Home","title":"ICAforECGrecordings.picardo","text":"picardo(X::AbstractMatrix, m::Int, maxiter::Int, tol::Z, lambda_min <: A, ls_tries:: Int, verbose::Bool) where{Z,A <:Real}\n\nRuns the Picard algorithm.\n\nArguments\n\nX::AbstractMatrix: Matrix that contains the signals that have to be unmixed. \nm::Int :  Size of L-BFGS's memory.\nmaxiter::Int : Maximal number of iterations for the algorithm\ntol::<:Real : tolerance for the stopping criterion. Iterations stop when the norm of the projected gradient gets smaller than tol.\nlambda_min::<:Real : Constant used to regularize the Hessian approximation. The eigenvalues of the approximation that are below lambdamin are shifted to lambdamin.\nls_tries::Int : Numer of tries allowed for the backtracking line-search. When that number is exceeded, the direction is thrown away and the gradient is used instead\nverbose::Bool : If true, prints the informations about the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.plot_dataset-Tuple{AbstractMatrix{Float64}}","page":"Home","title":"ICAforECGrecordings.plot_dataset","text":"plot_dataset(data::AbstractMatrix{Float64})\n\nPlot a dataset with time on the x-axis and multiple signals on the y-axis.\n\nArguments\n\ndata::AbstractMatrix{Float64}: Matrix where the first column represents time and the remaining columns represent different signals.\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.proj_hessian_approx-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.proj_hessian_approx","text":"proj_hessian_approx(Y :: AbstractMatrix,psidY_mean :: AbstractMatrix,G :: AbstractMatrix)\n\nComputes the projected Hessian approximation\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.read_dataset_from_dat-Tuple{String}","page":"Home","title":"ICAforECGrecordings.read_dataset_from_dat","text":"read_dataset_from_dat(Path :: String)\n\nReads a dataset from a .dat file.\n\nArguments\n\nPath::String: The path to the .dat file.\n\nReturns\n\nA matrix of type Float64 containing the data read from the file.\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.regularize_hessian-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T<:Real","page":"Home","title":"ICAforECGrecordings.regularize_hessian","text":"regularize_hessian(h :: AbstractMatrix,l :: T) where {T<:Real}\n\nClips the eigenvalues of h to l\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.shibbs","page":"Home","title":"ICAforECGrecordings.shibbs","text":"shibbs(X::AbstractMatrix,m::Int)\n\nBlind separation of real signals with SHIBBS.\n\nArguments\n\nX::AbstractMatrix:  Matrix that contains the signals that have to be unmixed. \nm=nothing: amount of signals that should be extracted from X. default same amount of singals as source\n\nReturns  B=shibbsR(X) a mxn separating matrix such that S=B*X is an mxT matrix of estimated source signals.\n\n\n\n\n\n","category":"function"},{"location":"#ICAforECGrecordings.solve-Tuple{JadeSeperator, AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.solve","text":"solve(seperator::AbstractSeperator, data::AbstractMatrix) -> AbstractMatrix\n\nPerforms Independent Component Analysis (ICA) using the specified algorithm on the provided data.\n\nArguments\n\nseperator: An instance of AbstractSeperator, which can be JadeSeperator, ShibbsSeperator, or PicardoSeperator.\ndata: A matrix of size (n_{samples}, n_{signals} + 1) where the first column is time in seconds and data[:, 2:end] contains the signal measurements.\n\nReturns\n\nA matrix of size (n_{samples}, n_{signals} + 1) where the first column is time and [:, 2:end] are the separated signals.  \n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.solve-Tuple{PicardSeperator, AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.solve","text":"solve(seperator::PicardoSeperator, data::AbstractMatrix) -> AbstractMatrix\n\nPerforms Independent Component Analysis (ICA) using the Picardo algorithm on the provided data.\n\nArguments\n\nseperator: An instance of PicardoSeperator, which can include parameters for the Picardo algorithm.\ndata: A matrix of size (n_{samples}, n_{signals} + 1) where the first column is time in seconds and data[:, 2:end] contains the signal measurements.\n\nReturns\n\nA matrix of size (n_{samples}, n_{signals} + 1) where the first column is time and [:, 2:end] are the separated signals.\n\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.solve-Tuple{ShibbsSeperator, AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.solve","text":"solve(seperator::ShibbsSeperator, data::AbstractMatrix) -> AbstractMatrix\n\nPerforms Independent Component Analysis (ICA) using the Shibbs algorithm on the provided data.\n\nArguments\n\nseperator: An instance of ShibbsSeperator.\ndata: A matrix of size (n_{samples}, n_{signals} + 1) where the first column is time in seconds and data[:, 2:end] contains the signal measurements.\n\nReturns\n\nA matrix of size (n_{samples}, n_{signals} + 1) where the first column is time and [:, 2:end] are the separated signals.\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.solve_hessian-Tuple{Any, Any}","page":"Home","title":"ICAforECGrecordings.solve_hessian","text":"solve_hessian(G,h)\n\nReturns the inverse Hessian times G\n\n\n\n\n\n","category":"method"},{"location":"#ICAforECGrecordings.whiten-Tuple{AbstractMatrix}","page":"Home","title":"ICAforECGrecordings.whiten","text":"whiten(data::AbstractMatrix) -> Tuple{Matrix, Matrix}\n\nPerforms whitening on the given data matrix.\n\nWhitening transforms the input signals so that each signal has unit variance and all signals are uncorrelated. This is a common preprocessing step before applying Independent Component Analysis (ICA).\n\nArguments\n\ndata: An abstract matrix of size (n_samples, n_signals+1) where the first column is time and the remaining n_signals columns are the observed signals.\n\nReturns\n\ndata_white::Matrix: A matrix of the same size as data, where the first column is the original time vector and the remaining columns are the whitened signals.\nW_white::Matrix: The whitening transform matrix of size (n_signals, n_signals) such that X_white = X_centered * W_white.\n\n\n\n\n\n","category":"method"}]
}
